# Chapter 1. Error Handling

## Running Example
* 你希望實作一個函式，用來解析檔案中的特定關鍵字，並回傳哪個關鍵字被找到的相關資訊
```c
int parseFile(char *file_name)
{
    int return_value = ERROR;
    FILE *file_pointer = 0;
    char *buffer = 0;
    if (file_name != NULL)
    {
        if (file_pointer = fopen(file_name, "r"))
        {
            if (buffer = malloc(BUFFER_SIZE))
            {
                /* parse file content*/
                return_value = NO_KEYWORD_FOUND;
                while (fgets(buffer, BUFFER_SIZE, file_pointer) != NULL)
                {
                    if (strcmp("KEYWORD_ONE\n", buffer) == 0)
                    {
                        return_value = KEYWORD_ONE_FOUND_FIRST;
                        break;
                    }
                    if (strcmp("KEYWORD_TWO\n", buffer) == 0)
                    {
                        return_value = KEYWORD_TWO_FOUND_FIRST;
                        break;
                    }
                }
                free(buffer);
            }
            fclose(file_pointer);
        }
    }
    return return_value;
}

```
### 說明
* 在這段程式碼中，你需要檢查每個函式呼叫的回傳值，以判斷是否有錯誤發生，因此導致程式碼中充滿了巢狀的 if 陳述式，這會帶來以下幾個問題：
1. 函式變得冗長，並且混合了錯誤處理、初始化、清理與功能性程式碼，這會讓維護變得困難。
2. 負責讀取與解析檔案資料的主體邏輯被深深地嵌套在 if 判斷中，讓程式邏輯難以追蹤。
3. 清理資源的程式碼與其初始化的地方相隔甚遠，這很容易讓人忘了釋放資源。尤其當函式中包含了多個 return 陳述式時，這種情況更為明顯。
* 為了改善這些問題，你首先進行了(Function Split)的重構。
## Function Split
```c
int searchFileForKeywords(char *buffer, FILE *file_pointer)
{
    while (fgets(buffer, BUFFER_SIZE, file_pointer) != NULL)
    {
        if (strcmp("KEYWORD_ONE\n", buffer) == 0)
        {
            return KEYWORD_ONE_FOUND_FIRST;
        }
        if (strcmp("KEYWORD_TWO\n", buffer) == 0)
        {
            return KEYWORD_TWO_FOUND_FIRST;
        }
    }
    return NO_KEYWORD_FOUND;
}
int parseFile(char *file_name)
{
    int return_value = ERROR;
    FILE *file_pointer = 0;
    char *buffer = 0;
    if (file_name != NULL)
    {
        if (file_pointer = fopen(file_name, "r"))
        {
            if (buffer = malloc(BUFFER_SIZE))
            {
                return_value = searchFileForKeywords(buffer,
                                                     file_pointer);
                free(buffer);
            }
            fclose(file_pointer);
        }
    }
    return return_value;
}
```
### 結果與效益
* 你改善了程式碼結構，因為兩個簡潔的函式比一個冗長的函式更容易閱讀與維護。例如：
1. 清理資源的程式碼更靠近其初始化的位置；
2. 資源配置與釋放的邏輯不會與主要功能邏輯混在一起；
3. 主程式邏輯因此更容易維護與擴充。

* 此外，被呼叫的函式（例如 mainFunctionality()）現在可以輕鬆使用多個 return 陳述式，因為它不必在每次 return 前處理資源釋放，這件事已由呼叫者負責集中處理。

* 但也有潛在問題：
如果被呼叫的函式需要用到多個資源，你必須將這些資源一一作為參數傳進函式。這樣會導致參數太多，使得程式碼不易閱讀，也容易在呼叫時傳錯順序導致錯誤。
* 要避免這種情況，你可以使用「聚合實例（Aggregate Instance）」，也就是建立一個結構體，將所有需要的資源打包在一起傳遞。


